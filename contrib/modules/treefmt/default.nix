{ types, ... } @ adios:
let
  self = {
    name = "treefmt";

    modules = adios.lib.importModules ./modules;

    inputs = {
      "nixpkgs" = {
        path = "/nixpkgs";
      };
    };

    types = {
      formatter = types.struct "treefmt-formatter-config" rec {
        command = types.union [
          types.string
          types.derivation # Allow setting command using writeShellScript & similar without casting to string
        ];
        includes = types.optionalAttr (types.listOf types.string);
        excludes = includes;
        options = includes;
      };
    };

    options = {
      formatters = {
        type = types.attrsOf self.types.formatter;
        # We don't define a list of mutators since we want the module to be
        # generic, but we do define how mutators are handled. These options are
        # ignored if mutators aren't set for the option, so you can still use
        # the option "normally"
        mutatorType = types.struct "treefmt-formatter" {
          name = types.string;
          treefmt = self.types.formatter;
        };
        mergeFunc =
          { mutators, inputs }:
          let
            inherit (inputs."nixpkgs") pkgs;
            inherit (pkgs) lib;
            inherit (builtins)
              attrValues
              groupBy
              head
              length
              mapAttrs
              ;
            inherit (lib) throwIf;
          in
          mapAttrs (
            name: formatters:
            let
              def = (head formatters).treefmt;
            in
            throwIf (length formatters > 1) "treefmt: name collision for formatter '${name}'" {
              inherit (def) command;
              includes = def.includes or [ ];
              options = def.options or [ ];
              excludes = def.excludes or [ ];
            }
          ) (groupBy (fmt: fmt.name) (attrValues mutators));
      };

      projectRootFile = {
        type = types.string;
      };

      package = {
        type = types.derivation;
        defaultFunc = { inputs }: inputs."nixpkgs".pkgs.treefmt;
      };

      excludes = {
        type = types.listOf types.string;
        default = [
          # generated lock files i.e. yarn, cargo, nix flakes
          "*.lock"
          # Files generated by patch
          "*.patch"

          # NPM
          "package-lock.json"

          # Go
          # In theory go mod tidy could format this, but it has other side-effects beyond formatting.
          "go.mod"
          "go.sum"

          # VCS
          ".gitignore"
          ".gitmodules"
          ".hgignore"
          ".svnignore"
        ];
      };
    };

    impl =
      { options, inputs }:
      let
        inherit (inputs."nixpkgs") pkgs;
        inherit (pkgs) lib;
        inherit (lib) getExe;

        config = {
          formatter = options.formatters;
          global.excludes = options.excludes;
        };

        configFile = (pkgs.formats.toml { }).generate "treefmt.toml" config;
      in
      pkgs.runCommand "treefmt-adios"
        {
          meta.mainProgram = "treefmt-adios";
        }
        ''
          mkdir -p $out/bin

          cat > $out/bin/$name << EOF
          #!${pkgs.runtimeShell}
          set -euo pipefail
          unset PRJ_ROOT
          exec ${getExe options.package} \
            --config-file=${configFile} \
            --tree-root-file=${options.projectRootFile} \
            "\$@"
          EOF
          chmod +x $out/bin/$name

          ln -s $out/bin/$name $out/bin/treefmt
        '';
  };
in
self
