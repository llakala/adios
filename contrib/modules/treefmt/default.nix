{ adios }:
let
  inherit (adios) types;
in
{
  name = "treefmt";

  modules = adios.lib.importModules ./modules;

  inputs = {
    "nixpkgs" = {
      path = "/nixpkgs";
    };
  };

  options = {
    formatters = {
      type = types.listOf (
        types.struct "treefmt-formatter" {
          name = types.string;

          treefmt = types.struct "treefmt-formatter-config" rec {
            command = types.union [
              types.string
              types.derivation # Allow setting command using writeShellScript & similar without casting to string
            ];
            includes = types.optionalAttr (types.listOf types.string);
            excludes = includes;
            options = includes;
          };
        }
      );
      default = [ ];
    };

    projectRootFile = {
      type = types.string;
    };

    package = {
      type = types.derivation;
      defaultFunc = { inputs }: inputs."nixpkgs".pkgs.treefmt;
    };

    excludes = {
      type = types.listOf types.string;
      default = [
        # generated lock files i.e. yarn, cargo, nix flakes
        "*.lock"
        # Files generated by patch
        "*.patch"

        # NPM
        "package-lock.json"

        # Go
        # In theory go mod tidy could format this, but it has other side-effects beyond formatting.
        "go.mod"
        "go.sum"

        # VCS
        ".gitignore"
        ".gitmodules"
        ".hgignore"
        ".svnignore"
      ];
    };
  };

  impl =
    { options, inputs }:
    let
      inherit (inputs."nixpkgs") pkgs;
      inherit (pkgs) lib;
      inherit (lib)
        groupBy
        mapAttrs
        head
        length
        throwIf
        getExe
        ;

      config = {
        formatter = mapAttrs (
          name: formatters:
          let
            def = (head formatters).treefmt;
          in
          throwIf (length formatters > 1) "treefmt: name collision for formatter '${name}'" {
            inherit (def) command;
            includes = def.includes or [ ];
            options = def.options or [ ];
            excludes = def.excludes or [ ];
          }
        ) (groupBy (fmt: fmt.name) options.formatters);
        global.excludes = options.excludes;
      };

      configFile = (pkgs.formats.toml { }).generate "treefmt.toml" config;

    in
    pkgs.runCommand "treefmt-adios"
      {
        meta.mainProgram = "treefmt-adios";
      }
      ''
        mkdir -p $out/bin

        cat > $out/bin/$name << EOF
        #!${pkgs.runtimeShell}
        set -euo pipefail
        unset PRJ_ROOT
        exec ${getExe options.package} \
          --config-file=${configFile} \
          --tree-root-file=${options.projectRootFile} \
          "\$@"
        EOF
        chmod +x $out/bin/$name

        ln -s $out/bin/$name $out/bin/treefmt
      '';
}
