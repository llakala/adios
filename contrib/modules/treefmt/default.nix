{ adios }:
let
  inherit (adios) types;

in

{
  name = "treefmt";

  modules = {
    nixfmt = import ./modules/nixfmt.nix { inherit adios; };
    statix = import ./modules/statix.nix { inherit adios; };
    deadnix = import ./modules/deadnix.nix { inherit adios; };
  };

  options = {
    formatters = {
      type = types.listOf (
        types.struct "treefmt-formatter" {
          name = types.string;

          treefmt = types.struct "treefmt-formatter-config" rec {
            command = types.union [
              types.string
              types.derivation # Allow setting command using writeShellScript & similar without casting to string
            ];
            includes = types.optionalAttr (types.listOf types.string);
            excludes = includes;
            options = includes;
          };
        }
      );
      default = [ ];
    };

    projectRootFile = {
      type = types.string;
    };

    package = {
      type = types.derivation;
      defaultFunc = { options, ... }: options.pkgs.treefmt;
    };

    pkgs = {
      type = types.attrs;
    };

    excludes = {
      type = types.listOf types.string;
      default = [
        # generated lock files i.e. yarn, cargo, nix flakes
        "*.lock"
        # Files generated by patch
        "*.patch"

        # NPM
        "package-lock.json"

        # Go
        # In theory go mod tidy could format this, but it has other side-effects beyond formatting.
        "go.mod"
        "go.sum"

        # VCS
        ".gitignore"
        ".gitmodules"
        ".hgignore"
        ".svnignore"
      ];
    };
  };

  impl =
    { options, ... }:
    let
      inherit (options) pkgs;
      inherit (pkgs) lib;
      inherit (lib)
        groupBy
        mapAttrs
        head
        length
        throwIf
        getExe
        ;

      config = {
        formatter = mapAttrs (
          name: formatters:
          let
            def = (head formatters).treefmt;
          in
          throwIf (length formatters > 1) "treefmt: name collision for formatter '${name}'" {
            inherit (def) command;
            includes = def.includes or [ ];
            options = def.options or [ ];
            excludes = def.excludes or [ ];
          }
        ) (groupBy (fmt: fmt.name) options.formatters);
        global.excludes = options.excludes;
      };

      configFile = (pkgs.formats.toml { }).generate "treefmt.toml" config;

    in
    {
      package =
        pkgs.runCommand "treefmt-adios"
          {
            meta.mainProgram = "treefmt-adios";
          }
          ''
            mkdir -p $out/bin

            cat > $out/bin/$name << EOF
            #!${pkgs.runtimeShell}
            set -euo pipefail
            unset PRJ_ROOT
            exec ${getExe options.package} \
              --config-file=${configFile} \
              --tree-root-file=${options.projectRootFile} \
              "\$@"
            EOF
            chmod +x $out/bin/$name

            ln -s $out/bin/$name $out/bin/treefmt
          '';
    };
}
